/**
 * @file odometry.hpp
 * @brief Odometry calculation for differential drive
 */

#ifndef ODOMETRY_HPP
#define ODOMETRY_HPP

#include <cstdint>
#include "config.hpp"

namespace odom {

/**
 * @brief Robot pose in 2D
 */
struct Pose {
    double x = 0.0;      // meters
    double y = 0.0;      // meters
    double theta = 0.0;  // radians
};

/**
 * @brief Robot velocities
 */
struct Velocity {
    double linear = 0.0;   // m/s
    double angular = 0.0;  // rad/s
    double left = 0.0;     // m/s
    double right = 0.0;    // m/s
};

/**
 * @brief Odometry tracker
 * 
 * Computes robot pose from wheel encoder readings. 
 * Uses midpoint integration for better accuracy.
 */
class OdometryTracker {
public:
    /**
     * @brief Reset odometry to origin
     */
    void reset();
    
    /**
     * @brief Reset odometry to specific pose
     */
    void reset(double x, double y, double theta);
    
    /**
     * @brief Update odometry with new encoder readings
     * @param left_ticks Current left encoder ticks (direction-corrected)
     * @param right_ticks Current right encoder ticks (direction-corrected)
     * @param timestamp_ms Current timestamp in milliseconds
     */
    void update(int64_t left_ticks, int64_t right_ticks, uint32_t timestamp_ms);
    
    /**
     * @brief Get current pose
     */
    const Pose& get_pose() const { return pose_; }
    
    /**
     * @brief Get current velocities
     */
    const Velocity& get_velocity() const { return velocity_; }

private:
    Pose pose_;
    Velocity velocity_;
    
    int64_t prev_left_ticks_ = 0;
    int64_t prev_right_ticks_ = 0;
    uint32_t prev_timestamp_ms_ = 0;
    bool initialized_ = false;
    
    /**
     * @brief Normalize angle to [-pi, pi]
     */
    static double normalize_angle(double angle);
};

}  // namespace odom

#endif  // ODOMETRY_HPP