"""
MPU6050 I2C driver for Raspberry Pi. 

This driver communicates with the MPU6050 over I2C to read: 
- 3-axis accelerometer data
- 3-axis gyroscope data
- Temperature

Author: Rover Team
"""

import struct
import time
from typing import Tuple, Optional
from dataclasses import dataclass


@dataclass
class IMUData:
    """Container for IMU sensor data."""
    accel_x: float  # m/s^2
    accel_y: float  # m/s^2
    accel_z: float  # m/s^2
    gyro_x: float   # rad/s
    gyro_y:  float   # rad/s
    gyro_z: float   # rad/s
    temperature: float  # Celsius
    timestamp: float    # Unix timestamp


class MPU6050Driver: 
    """
    Driver for MPU6050 6-axis IMU over I2C.
    
    The MPU6050 provides: 
    - 3-axis accelerometer (±2g, ±4g, ±8g, ±16g ranges)
    - 3-axis gyroscope (±250, ±500, ±1000, ±2000 deg/s ranges)
    - Temperature sensor
    """
    
    # Default I2C address (AD0 pin low)
    DEFAULT_ADDRESS = 0x68
    ALT_ADDRESS = 0x69  # AD0 pin high
    
    # Register addresses
    REG_PWR_MGMT_1 = 0x6B
    REG_PWR_MGMT_2 = 0x6C
    REG_SMPLRT_DIV = 0x19
    REG_CONFIG = 0x1A
    REG_GYRO_CONFIG = 0x1B
    REG_ACCEL_CONFIG = 0x1C
    REG_ACCEL_XOUT_H = 0x3B
    REG_TEMP_OUT_H = 0x41
    REG_GYRO_XOUT_H = 0x43
    REG_WHO_AM_I = 0x75
    
    # Expected WHO_AM_I value
    WHO_AM_I_VAL = 0x68
    
    # Conversion constants
    GRAVITY = 9.80665  # m/s^2
    DEG_TO_RAD = 0.017453292519943295  # pi/180
    
    # Scale factors (based on configured range)
    ACCEL_SCALE_2G = 16384.0   # LSB/g
    ACCEL_SCALE_4G = 8192.0
    ACCEL_SCALE_8G = 4096.0
    ACCEL_SCALE_16G = 2048.0
    
    GYRO_SCALE_250 = 131.0     # LSB/(deg/s)
    GYRO_SCALE_500 = 65.5
    GYRO_SCALE_1000 = 32.8
    GYRO_SCALE_2000 = 16.4
    
    def __init__(
        self,
        bus_number: int = 1,
        address: int = DEFAULT_ADDRESS,
        accel_range: int = 2,  # ±2g
        gyro_range: int = 250  # ±250 deg/s
    ):
        """
        Initialize MPU6050 driver.
        
        Args:
            bus_number: I2C bus number (usually 1 on Pi)
            address: I2C address of the MPU6050
            accel_range: Accelerometer range (2, 4, 8, or 16 g)
            gyro_range:  Gyroscope range (250, 500, 1000, or 2000 deg/s)
        """
        self.bus_number = bus_number
        self.address = address
        self._bus = None
        self._initialized = False
        
        # Set scale factors based on range
        self._set_accel_scale(accel_range)
        self._set_gyro_scale(gyro_range)
        
        # Calibration offsets
        self. accel_offset = [0.0, 0.0, 0.0]
        self.gyro_offset = [0.0, 0.0, 0.0]
    
    def _set_accel_scale(self, range_g: int):
        """Set accelerometer scale factor."""
        scales = {
            2: (self.ACCEL_SCALE_2G, 0x00),
            4: (self. ACCEL_SCALE_4G, 0x08),
            8: (self. ACCEL_SCALE_8G, 0x10),
            16: (self. ACCEL_SCALE_16G, 0x18)
        }
        if range_g not in scales:
            range_g = 2
        self._accel_scale, self._accel_config = scales[range_g]
    
    def _set_gyro_scale(self, range_dps: int):
        """Set gyroscope scale factor."""
        scales = {
            250: (self.GYRO_SCALE_250, 0x00),
            500: (self. GYRO_SCALE_500, 0x08),
            1000: (self.GYRO_SCALE_1000, 0x10),
            2000: (self.GYRO_SCALE_2000, 0x18)
        }
        if range_dps not in scales:
            range_dps = 250
        self._gyro_scale, self._gyro_config = scales[range_dps]
    
    def initialize(self) -> bool:
        """
        Initialize the MPU6050.
        
        Returns:
            True if initialization successful, False otherwise. 
        """
        try:
            import smbus2
            self._bus = smbus2.SMBus(self.bus_number)
            
            # Check WHO_AM_I register
            who_am_i = self._bus.read_byte_data(self.address, self. REG_WHO_AM_I)
            if who_am_i != self.WHO_AM_I_VAL:
                print(f"Unexpected WHO_AM_I value:  0x{who_am_i:02X}")
                return False
            
            # Wake up the device (clear sleep bit)
            self._bus.write_byte_data(self.address, self.REG_PWR_MGMT_1, 0x00)
            time.sleep(0.1)
            
            # Set clock source to PLL with X-axis gyro reference
            self._bus.write_byte_data(self.address, self.REG_PWR_MGMT_1, 0x01)
            
            # Configure sample rate divider (1kHz / (1 + div) = sample rate)
            # For 200 Hz:  div = 4
            self._bus.write_byte_data(self.address, self.REG_SMPLRT_DIV, 0x04)
            
            # Configure DLPF (Digital Low Pass Filter)
            # 0x03 = 44Hz bandwidth for accel, 42Hz for gyro
            self._bus.write_byte_data(self.address, self.REG_CONFIG, 0x03)
            
            # Configure gyroscope range
            self._bus. write_byte_data(self. address, self.REG_GYRO_CONFIG, self._gyro_config)
            
            # Configure accelerometer range
            self._bus.write_byte_data(self.address, self. REG_ACCEL_CONFIG, self._accel_config)
            
            self._initialized = True
            return True
            
        except Exception as e:
            print(f"Failed to initialize MPU6050: {e}")
            return False
    
    def read(self) -> Optional[IMUData]:
        """
        Read all sensor data.
        
        Returns:
            IMUData containing all sensor readings, or None if read failed.
        """
        if not self._initialized or self._bus is None:
            return None
        
        try: 
            # Read 14 bytes starting from ACCEL_XOUT_H
            # Order: AccelX, AccelY, AccelZ, Temp, GyroX, GyroY, GyroZ
            data = self._bus.read_i2c_block_data(self.address, self.REG_ACCEL_XOUT_H, 14)
            
            # Convert bytes to signed 16-bit integers
            raw_accel_x = self._bytes_to_int16(data[0], data[1])
            raw_accel_y = self._bytes_to_int16(data[2], data[3])
            raw_accel_z = self._bytes_to_int16(data[4], data[5])
            raw_temp = self._bytes_to_int16(data[6], data[7])
            raw_gyro_x = self._bytes_to_int16(data[8], data[9])
            raw_gyro_y = self._bytes_to_int16(data[10], data[11])
            raw_gyro_z = self._bytes_to_int16(data[12], data[13])
            
            # Convert to physical units
            accel_x = (raw_accel_x / self._accel_scale) * self.GRAVITY - self.accel_offset[0]
            accel_y = (raw_accel_y / self._accel_scale) * self.GRAVITY - self.accel_offset[1]
            accel_z = (raw_accel_z / self._accel_scale) * self.GRAVITY - self.accel_offset[2]
            
            # Temperature:  Temp_degC = (raw / 340) + 36.53
            temperature = (raw_temp / 340.0) + 36.53
            
            # Gyro: convert to rad/s
            gyro_x = (raw_gyro_x / self._gyro_scale) * self.DEG_TO_RAD - self.gyro_offset[0]
            gyro_y = (raw_gyro_y / self._gyro_scale) * self.DEG_TO_RAD - self.gyro_offset[1]
            gyro_z = (raw_gyro_z / self._gyro_scale) * self.DEG_TO_RAD - self.gyro_offset[2]
            
            return IMUData(
                accel_x=accel_x,
                accel_y=accel_y,
                accel_z=accel_z,
                gyro_x=gyro_x,
                gyro_y=gyro_y,
                gyro_z=gyro_z,
                temperature=temperature,
                timestamp=time. time()
            )
            
        except Exception as e:
            print(f"Failed to read MPU6050: {e}")
            return None
    
    def calibrate(self, num_samples: int = 100, delay_ms: int = 10) -> bool:
        """
        Calibrate the IMU by averaging readings while stationary.
        
        The robot must be stationary and level during calibration! 
        
        Args:
            num_samples: Number of samples to average
            delay_ms:  Delay between samples in milliseconds
            
        Returns:
            True if calibration successful
        """
        if not self._initialized: 
            return False
        
        print(f"Calibrating IMU ({num_samples} samples)...")
        print("Keep the robot stationary and level!")
        
        accel_sum = [0.0, 0.0, 0.0]
        gyro_sum = [0.0, 0.0, 0.0]
        valid_samples = 0
        
        for i in range(num_samples):
            data = self.read()
            if data: 
                accel_sum[0] += data.accel_x
                accel_sum[1] += data.accel_y
                accel_sum[2] += data.accel_z
                gyro_sum[0] += data.gyro_x
                gyro_sum[1] += data.gyro_y
                gyro_sum[2] += data.gyro_z
                valid_samples += 1
            time.sleep(delay_ms / 1000.0)
        
        if valid_samples < num_samples * 0.9:
            print(f"Calibration failed: only {valid_samples}/{num_samples} valid samples")
            return False
        
        # Calculate offsets
        # For gyro, offset is the mean (should be zero when stationary)
        self.gyro_offset[0] = gyro_sum[0] / valid_samples
        self.gyro_offset[1] = gyro_sum[1] / valid_samples
        self.gyro_offset[2] = gyro_sum[2] / valid_samples
        
        # For accelerometer, Z axis should read 1g when level
        # X and Y should be zero
        self.accel_offset[0] = accel_sum[0] / valid_samples
        self.accel_offset[1] = accel_sum[1] / valid_samples
        self.accel_offset[2] = (accel_sum[2] / valid_samples) - self.GRAVITY
        
        print("Calibration complete!")
        print(f"Accel offsets: {self.accel_offset}")
        print(f"Gyro offsets: {self.gyro_offset}")
        
        return True
    
    def close(self):
        """Close the I2C bus."""
        if self._bus:
            self._bus.close()
            self._bus = None
        self._initialized = False
    
    @staticmethod
    def _bytes_to_int16(msb:  int, lsb: int) -> int:
        """Convert two bytes to signed 16-bit integer."""
        value = (msb << 8) | lsb
        if value >= 0x8000:
            value -= 0x10000
        return value