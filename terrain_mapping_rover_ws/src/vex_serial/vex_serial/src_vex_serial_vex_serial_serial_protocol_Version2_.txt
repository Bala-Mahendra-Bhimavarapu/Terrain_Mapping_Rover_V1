"""
Serial protocol handler for VEX V5 communication. 
Handles low-level serial I/O with checksum validation.
"""

import serial
import threading
import time
from typing import Optional, Callable, Tuple
from dataclasses import dataclass
from enum import Enum


class MessageType(Enum):
    """Types of messages in the protocol."""
    ODOM = "ODOM"
    STATUS = "STATUS"
    ACK = "ACK"
    ERROR = "ERROR"
    CMD = "CMD"


@dataclass
class OdomMessage:
    """Parsed odometry message from VEX V5."""
    left_ticks: int
    right_ticks: int
    left_velocity: float  # ticks/sec
    right_velocity: float  # ticks/sec
    timestamp_ms: int
    valid: bool = True


@dataclass
class StatusMessage:
    """Parsed status message from VEX V5."""
    battery_voltage: float
    motor_temps: Tuple[float, float, float, float]
    connected: bool = True


class VexSerialProtocol: 
    """
    Handles serial communication with VEX V5 Brain.
    
    Protocol Format:
    ----------------
    Pi → V5:  CMD,<left_vel>,<right_vel>,<checksum>\n
              - left_vel, right_vel in m/s (float, 3 decimal places)
              - checksum = sum of all bytes before checksum % 256
    
    V5 → Pi:  ODOM,<left_ticks>,<right_ticks>,<left_vel>,<right_vel>,<timestamp>,<checksum>\n
              - ticks: cumulative encoder ticks (int)
              - vel: ticks/sec (float)
              - timestamp: ms since V5 start (int)
              
    V5 → Pi:   STATUS,<battery_v>,<temp1>,<temp2>,<temp3>,<temp4>,<checksum>\n
    """
    
    # Protocol constants
    MSG_TERMINATOR = b'\n'
    FIELD_SEPARATOR = ','
    CHECKSUM_MODULO = 256
    
    def __init__(
        self,
        port: str = '/dev/ttyACM0',
        baudrate: int = 115200,
        timeout: float = 0.1,
        reconnect_delay: float = 1.0,
        max_reconnect_attempts: int = 10
    ):
        """
        Initialize the serial protocol handler.
        
        Args:
            port: Serial port path
            baudrate: Baud rate (default 115200)
            timeout: Read timeout in seconds
            reconnect_delay: Delay between reconnection attempts
            max_reconnect_attempts: Max reconnection attempts (0 = infinite)
        """
        self. port = port
        self.baudrate = baudrate
        self. timeout = timeout
        self.reconnect_delay = reconnect_delay
        self.max_reconnect_attempts = max_reconnect_attempts
        
        self._serial:  Optional[serial.Serial] = None
        self._connected = False
        self._running = False
        
        # Callbacks
        self._odom_callback:  Optional[Callable[[OdomMessage], None]] = None
        self._status_callback: Optional[Callable[[StatusMessage], None]] = None
        self._error_callback: Optional[Callable[[str], None]] = None
        
        # Statistics
        self._message_count = 0
        self._error_count = 0
        self._checksum_errors = 0
        
        # Thread safety
        self._write_lock = threading.Lock()
        self._read_thread:  Optional[threading.Thread] = None
        
    @property
    def connected(self) -> bool:
        """Return connection status."""
        return self._connected
    
    @property
    def message_count(self) -> int:
        """Return total messages received."""
        return self._message_count
    
    @property
    def error_count(self) -> int:
        """Return total errors."""
        return self._error_count
    
    @property
    def checksum_errors(self) -> int:
        """Return checksum error count."""
        return self._checksum_errors
    
    def set_odom_callback(self, callback:  Callable[[OdomMessage], None]):
        """Set callback for odometry messages."""
        self._odom_callback = callback
    
    def set_status_callback(self, callback: Callable[[StatusMessage], None]):
        """Set callback for status messages."""
        self._status_callback = callback
    
    def set_error_callback(self, callback: Callable[[str], None]):
        """Set callback for error messages."""
        self._error_callback = callback
    
    def connect(self) -> bool:
        """
        Attempt to connect to the serial port. 
        
        Returns:
            True if connection successful, False otherwise. 
        """
        try: 
            self._serial = serial.Serial(
                port=self.port,
                baudrate=self. baudrate,
                timeout=self.timeout,
                write_timeout=self.timeout
            )
            
            # Clear buffers
            self._serial.reset_input_buffer()
            self._serial.reset_output_buffer()
            
            self._connected = True
            return True
            
        except serial.SerialException as e:
            self._report_error(f"Failed to connect to {self.port}: {e}")
            self._connected = False
            return False
    
    def disconnect(self):
        """Disconnect from serial port."""
        self._running = False
        
        if self._read_thread and self._read_thread.is_alive():
            self._read_thread.join(timeout=2.0)
        
        if self._serial and self._serial.is_open:
            self._serial.close()
        
        self._connected = False
    
    def start_reading(self):
        """Start the background reading thread."""
        if self._running:
            return
        
        self._running = True
        self._read_thread = threading.Thread(target=self._read_loop, daemon=True)
        self._read_thread.start()
    
    def stop_reading(self):
        """Stop the background reading thread."""
        self._running = False
        if self._read_thread:
            self._read_thread.join(timeout=2.0)
    
    def send_velocity_command(self, left_vel: float, right_vel: float) -> bool:
        """
        Send velocity command to VEX V5.
        
        Args:
            left_vel: Left wheel velocity in m/s
            right_vel: Right wheel velocity in m/s
            
        Returns:
            True if sent successfully, False otherwise. 
        """
        if not self._connected or not self._serial:
            return False
        
        # Format:  CMD,<left>,<right>,<checksum>\n
        msg_body = f"CMD,{left_vel:. 3f},{right_vel:.3f}"
        checksum = self._calculate_checksum(msg_body)
        full_msg = f"{msg_body},{checksum}\n"
        
        try:
            with self._write_lock:
                self._serial.write(full_msg.encode('ascii'))
                self._serial.flush()
            return True
        except serial.SerialException as e:
            self._report_error(f"Write error: {e}")
            self._handle_disconnect()
            return False
    
    def send_emergency_stop(self) -> bool:
        """Send emergency stop command."""
        return self.send_velocity_command(0.0, 0.0)
    
    def _read_loop(self):
        """Background thread for reading serial data."""
        reconnect_attempts = 0
        
        while self._running:
            if not self._connected:
                # Attempt reconnection
                if self.max_reconnect_attempts > 0 and reconnect_attempts >= self.max_reconnect_attempts:
                    self._report_error("Max reconnection attempts reached")
                    break
                
                time.sleep(self.reconnect_delay)
                if self.connect():
                    reconnect_attempts = 0
                else:
                    reconnect_attempts += 1
                continue
            
            try:
                # Read a line
                line = self._serial.readline()
                if not line:
                    continue
                
                # Decode and parse
                try:
                    message = line.decode('ascii').strip()
                    if message:
                        self._parse_message(message)
                except UnicodeDecodeError: 
                    self._error_count += 1
                    continue
                    
            except serial.SerialException as e:
                self._report_error(f"Read error: {e}")
                self._handle_disconnect()
    
    def _parse_message(self, message: str):
        """Parse a received message."""
        parts = message. split(self.FIELD_SEPARATOR)
        if len(parts) < 2:
            self._error_count += 1
            return
        
        msg_type = parts[0]
        
        # Validate checksum (last field)
        try:
            received_checksum = int(parts[-1])
            body = self. FIELD_SEPARATOR.join(parts[:-1])
            expected_checksum = self._calculate_checksum(body)
            
            if received_checksum != expected_checksum:
                self._checksum_errors += 1
                self._error_count += 1
                return
        except ValueError:
            self._error_count += 1
            return
        
        self._message_count += 1
        
        # Route to appropriate handler
        if msg_type == MessageType.ODOM. value:
            self._handle_odom_message(parts)
        elif msg_type == MessageType.STATUS.value:
            self._handle_status_message(parts)
        elif msg_type == MessageType.ERROR.value:
            if len(parts) >= 2:
                self._report_error(f"V5 Error: {parts[1]}")
    
    def _handle_odom_message(self, parts: list):
        """Parse and dispatch odometry message."""
        # Format: ODOM,left_ticks,right_ticks,left_vel,right_vel,timestamp,checksum
        if len(parts) != 7:
            self._error_count += 1
            return
        
        try:
            odom = OdomMessage(
                left_ticks=int(parts[1]),
                right_ticks=int(parts[2]),
                left_velocity=float(parts[3]),
                right_velocity=float(parts[4]),
                timestamp_ms=int(parts[5])
            )
            
            if self._odom_callback:
                self._odom_callback(odom)
                
        except (ValueError, IndexError):
            self._error_count += 1
    
    def _handle_status_message(self, parts: list):
        """Parse and dispatch status message."""
        # Format: STATUS,battery_v,temp1,temp2,temp3,temp4,checksum
        if len(parts) != 7:
            self._error_count += 1
            return
        
        try:
            status = StatusMessage(
                battery_voltage=float(parts[1]),
                motor_temps=(
                    float(parts[2]),
                    float(parts[3]),
                    float(parts[4]),
                    float(parts[5])
                )
            )
            
            if self._status_callback:
                self._status_callback(status)
                
        except (ValueError, IndexError):
            self._error_count += 1
    
    def _calculate_checksum(self, data: str) -> int:
        """Calculate simple checksum for data."""
        return sum(ord(c) for c in data) % self.CHECKSUM_MODULO
    
    def _handle_disconnect(self):
        """Handle serial disconnection."""
        self._connected = False
        if self._serial:
            try:
                self._serial.close()
            except:
                pass
    
    def _report_error(self, message: str):
        """Report an error via callback."""
        self._error_count += 1
        if self._error_callback:
            self._error_callback(message)